import numpy as np
import helpers as h
from solver.ik_solver import KDLIKSolver


def ik_soln_exists(goal_pose, kin):
    goal_angles = None
    if goal_pose is not None:
        goal_angles = None
        if goal_pose:
            goal_angles = kin.solve(position=goal_pose.position, orientation=goal_pose.orientation)
    if goal_angles is not None:
        return True, goal_angles
    else:
        return False, None


class RRT:
    # one-way RRT

    def __init__(self, q_start, p_goal, kin_solver, side):
        self.kin = kin_solver
        self.q_start = q_start
        self.x_goal = h.pose_to_ndarray(p_goal)
        self.p_goal = p_goal
        self.nodes = []
        self.side = side

    def add_nodes(self, nodes_to_add):
        self.nodes.extend(nodes_to_add)

    def curr_node(self):
        if len(self.nodes) == 0:
            return self.q_start
        return self.nodes[-1]

    def goal_pose(self):
        return self.p_goal

    def goal_node(self):
        return self.x_goal

    def goal_point(self):
        return self.goal_node()[:3]

    def dist(self, start, stop):
        return np.linalg.norm(stop[:3] - start[:3])

    def _dist_to_goal(self, curr):
        return self.dist(curr, self.goal_node())

    def dist_to_goal(self):
        return self._dist_to_goal(self.fwd_kin(self.curr_node()))

    def closest_node_to_goal(self):
        return self.curr_node()

    def workspace_delta(self, x_curr):
        return (self.x_goal - x_curr)[:6]

    def fwd_kin(self, q_list):
        return self.kin.solve_fwd_kin(q_list)

    def collision_free(self, q_new_angles, obstacle_waves, obs_mapping_fn, min_thresh=0.05):
        x_new = np.array(self.fwd_kin(q_new_angles)[:3])
        return self._check_collisions(x_new, obstacle_waves, obs_mapping_fn, min_thresh)

    def _check_collisions(self, x, obstacle_waves, obs_mapping_fn, min_thresh):
        x_indx = obs_mapping_fn(x, self.goal_point())
        if len(obstacle_waves) > x_indx:
            obs_wave = obstacle_waves[x_indx]
            for obs in obs_wave:
                if np.linalg.norm(obs-x) < min_thresh:
                    print "collisions found for rrt point..."
                    return False
        return True

    def extend_toward_goal(self, obstacle_waves, obs_mapping_fn, dist_thresh=0.1):
        # returns the distance of the last nearest node to goal generated by this method
        # get the closest node to goal and try to complete the tree
        q_old = self.closest_node_to_goal()
        first = True
        Q_new = []
        prev_dist_to_goal = self.dist_to_goal()
        while first or prev_dist_to_goal > dist_thresh:
            if first:
                first = False
            J_T = self.kin.jacobian_transpose(q_old)
            x_old = self.fwd_kin(q_old)
            d_x = self.workspace_delta(x_old)
            d_q = np.dot(J_T, d_x).tolist()
            d_q = np.array(d_q[0])
            q_new = q_old + d_q
            curr_dist_to_goal = self._dist_to_goal(self.fwd_kin(q_new))
            if curr_dist_to_goal < prev_dist_to_goal: #and self.collision_free(q_new, obstacle_waves,
                                                     #                        obs_mapping_fn):
                print "random step: curr dist to goal: " + str(self._dist_to_goal(self.fwd_kin(q_new)))
                Q_new.append(q_new)
                q_old = q_new
                prev_dist_to_goal = curr_dist_to_goal
            else:
                break
        self.add_nodes(Q_new)

    def ik_extend_randomly(self, curr_pos, obstacle_waves, obs_mapping_fn, dist_thresh, offset=0.1):
        # returns the nearest distance to goal from the last node added by this method
        # only add one node via random soln for now
        goal_arr = self.goal_node()
        goal_pose = self.goal_pose()
        # first = True
        Q_new = []
        prev_dist_to_goal = self.dist_to_goal()
        while prev_dist_to_goal > dist_thresh:
            next_point = []
            for i in range(3):
                curr_coord = curr_pos[i]
                goal_coord = goal_arr[i]
                if curr_coord < goal_coord:
                    next_point.append(h.generate_random_decimal(curr_coord-offset, goal_coord+offset))
                else:
                    next_point.append(h.generate_random_decimal(goal_coord-offset, curr_coord+offset))

            #if self._check_collisions(next_point, obstacle_waves, obs_mapping_fn, dist_thresh):
            next_pose = h.generate_goal_pose_w_same_orientation(next_point, goal_pose.orientation)
            solved, q_new = ik_soln_exists(next_pose, self.kin)
            if solved:
                curr_dist_to_goal = self._dist_to_goal(self.fwd_kin(q_new))
                curr_pos = next_point
                print "ik planner: curr dist to goal: " + str(self._dist_to_goal(self.fwd_kin(q_new)))
                Q_new.append(q_new)
                prev_dist_to_goal = curr_dist_to_goal
            else:
                break
        self.add_nodes(Q_new)
